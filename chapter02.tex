%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Обзор существующих решений}\label{ch:обзор-существующих-решений}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Проблема не безопасной инициализации берет свое начало от \textit{the billion dollar mistake}\cite{the-billion-dollar-mistake}
Обращение еще к неинициализированным полям является проблемой не только для языка Kotlin, но и для многих других языков.
В индустриальных языках существует два классических подхода для решения данной проблемы.

Первый способ --- это запретить программисту писать некоторый код на стадии инициализации,
зато гарантировать ему безопасную инициализацию.
Данный подход использует язык Swift.

Второй способ --- это не отслеживать ошибки инициализации, но разрешать программисту писать практически любой код.
Такой подход используют такие языки как Kotlin, Scala 2, Java и многие другие.
Данное решение хорошо тем, что оно дает программисту достаточное количество свободы,
и не заставляет его пытаться обойти ограничения, которые вводит первый подход.
\info[inline]{Мб примерчик на Swift, для инициализации циклических структур данных с нулями итд}

На самом деле существует и третий подход, он рассмотрен в \autoref{sec:инициализации-в-dart} с языком Dart.
Это скорее способ смягчить данную проблему, а не решить ее полностью.

\section{Безопасная инициализация в языке Kotlin}\label{sec:безопасная-инициализация-в-языке-kotlin}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В языке Kotlin нет безопасной инициализации, но есть ряд небольших проверок.
В интегрированной среде разработки IntelliJ IDEA, существуют средства,
которые анализируют код и могут сообщать о неэффективном или небезопасном коде.
Одно из таких средств умеет анализировать код на языке Kotlin и находить проблемы связанные с проблемой \textit{утекшего this}.\unsure{ссылочка на глухих или код}
Данный анализ достаточно слабый и чтобы его обмануть достаточно обернуть проблемный код в вызов метода.
\lstinputlisting[
    label={lst:charter02-inheritance},
    caption={Пример не безопасной инициализации},
    language=Kotlin,
]
{src/charter02/Inheritance.kt}
Если для кода приведенного в листинге~\ref{lst:charter01-inheritance} пользователь получит предупреждение в IntelliJ IDEA,
то для кода примера выше предупреждения не будет, но данные коды одинаково не безопасны.
Таким образом, данный анализ может найти только прямые обращения к свойствам и методам, которые можно переопределить,
во время построения объекта.
Более того, он не находит ошибки инициализации, и если переопределение безопасно как в примере ниже,
он все равно будет показывать предупреждение.
\lstinputlisting[
    label={lst:charter02-inheritance1},
    caption={Пример не безопасной инициализации},
    language=Kotlin,
]
{src/charter02/Inheritance1.kt}
Данный код не имеет ошибок инициализации, но программист все равно будет получать ошибки инициализации.
Да, это не большая проблема, потому что такой код не самый безопасный, но иногда приходится его писать.

Также, в языке Kotlin есть анализ, который проверяет, что все свойства были инициализированы и,
что нет доступа к еще неинициализированным свойствам, но данный анализ имеет ту же проблему, что и предыдущий,
если обернуть проблему в вызов метода анализ не сможет ее найти.
Например, код из листинга~\ref{lst:charter01-simple} компилируется и не предупреждает об использовании свойства \emph{name}
до его инициализации.

Таким образом способы обеспечения безопасной инициализации реализованные в данный момент, не могут в полной мере,
найти все ошибки инициализации.


\section{Инициализации в языке Swift}\label{sec:инициализации-в-языке-swift}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В языке Swift по сути решена проблема с ошибками инициализации.
Решение достаточно радикальное, но оно хорошо справляется с данными ошибками.
В языке Swift существует две стадии инициализации, во время первой стадии запрещено вызывать методы,
обращаться к свойствам и использовать \emph{self}(аналог \emph{this}).\nomenclature{\emph{self}}{\emph{this} в языке Swift}
Она длится пока не будут инициализированы все свойства.
То есть, получить доступ к еще не инициализированному свойству нельзя.
Так, естественным образом решается проблема не безопасной инициализации.

Данный подход имеет одно не очень приятное свойство, для написания некоторого кода программисту иногда приходится жертвовать
неизменяемостью и null-безопасностью.
Например, для создания циклической структуры данных из примера ниже, свойство \emph{child} должно быть изменяемое и иметь nullable тип.
Это не очень хорошо, так как такой код тяжелее поддерживать и больше вероятность ошибиться.\unsure{ссылочка куда-нибудь}
\begin{lstlisting}[
    language=Swift,
    caption={Циклическая структура данных в языке Swift},
    label={lst:cyclic-data-structure-swift}
]
class Parent {
  var child: Child? = nil
  let tag = "Parent"
  init() {
    child = Child(p: self)
  }
}

class Child {
  let parent: Parent
  init(p: Parent) {
    parent = p
  }
}
\end{lstlisting}

\section{Инициализации в Dart}\label{sec:инициализации-в-dart}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\info [inline]{Если хватит времени рассмотреть инициализацию в Dart}


\section{Маскирующие типы}\label{sec:маскирующие-типы}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Одним из многообещающих подходов является решение основывающееся на маскирующих типах\cite{masked-types}.
Данный подход представляет чувствительную к потоку систему типов и эффектов для безопасной инициализации.
Маскирующий тип $T \backslash f$ значит, что на данной стадии инициализации типа $T$ нельзя получить доступ к полю $f$.
В работе вводятся эффекты, которые передают информацию о маске между вызовами методов.
\begin{lstlisting}[
    caption={Маскирующие типы},
    label={lst:masked-types}]
Point(int x, int y) effect * -> Point.sub
void display() effect {} -> {}
\end{lstlisting}
В данном случае конструктор \emph{Point} может быть вызван, когда ни одно поле еще не инициализировано, это означает \emph{*}.
При этом после построения получается объект с маской, у которого все поля класса \emph{Point} были инициализированы,
а все поля подклассов еще не инициализированы.
Эффект для метода \emph{display} переносит информацию, что данный метод может быть вызван только если все поля были инициализированы,
и возвращает тоже полностью инициализированный объект.

Данный подход обладает набором приятных свойств.
Он поддерживает абстрактные классы, циклические структуры данных, внутренние классы, typestate\change{где-то объяснить что это такое} полиморфизм,
а также может быть расширен на другие сложные конструкции.
Но у подхода есть и ряд серьезных недостатков.
Так, анализ поддерживает typestate полиморфизм, но в нем нельзя выразить,
что метод можно использовать при любом статусе инициализированности.
Вторым серьезным минусом данного подхода является, обширный дополнительный синтаксис.
Авторы статьи утверждают, что можно сделать систему вывода, но в данной и следующих статьях такой возможности не представлено.


\section{Freedom before commitment}\label{sec:the-freedom-model}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В работе <<Freedom before commitment>>(далее nome\nomenclature{FBC}{Freedom before commitment})\cite{the-freedom-model}\unsure {это не полное название полное достаточно длинное} представляется нечувствительную к потоку
систему типов и эффектов для безопасной инициализации.
В данной работе объекты делятся на два вида свободные и зафиксированные.
Свободные объекты --- это объекты, обращение к полям, которых может давать null.
Зафиксированные объекты --- это полностью инициализированные объекты обращение к которым полностью безопасно.
Выделяется четыре приятных свойства данного анализа:
\begin{itemize*}
    \item Модульность: Классы проверяются по отдельности.
    \item Надежность: Если объект имеет зафиксированный статус, то использование данного объекта гарантировано безопасно
    \item Выразительность: Данный подход поддерживает сложный код, как инициализация циклических структур данных
    \item Простота: Подход не требует большего числа аннотаций в отличие от маскирующих типов из раздела~\ref{sec:маскирующие-типы}
\end{itemize*}

Но отмечается и ряд недостатков, так в данной системе не реализована система вывода типов,
а значит программистам придется самим помечать объекты в своем коде.
Также, проблемой подхода является не возможность использования уже инициализированных полей во время конструирования объекта.
Авторы статьи предлагают использовать анализ потока данных для того, чтобы находить уже инициализированные поля,
но не реализуют такой возможности.
Более серьёзной проблемой с точки зрения анализа является плохая поддержка typestate полиморфизма.
\begin{lstlisting}[
    caption={Проблема c typestate полиморфизмом в подходе},
    label={lst:freedom-model},
    language=Kotlin]
    class Parent {
        val child = Child(this)   // недоинициализированное значение
        val tag: Int = child.tag  // ошибка
    }
    class Child(parent: Parent @free) {
        val tag = 10
    }
\end{lstlisting}
Так, для кода выше была бы выдана ошибка инициализации, так как значения \emph{child} недоинициализировано,
а значит оно свободное.
Следовательно, нельзя обращаться к его методам.

Данный подход один из первых сделал анализ, достаточно простым и выразительным, чтобы его можно было использовать в разработке.
При этом подход может иметь ряд дополнений, которые позволят сделать анализ более безопасным и простым.

\section{Безопасная инициализация для языка Scala 3}\label{sec:безопасная-инициализация-для-языка-scala-3}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Развитием идей представленных в работе FBC,
является система типов и эффектов для безопасной инициализации представленная для языка Scala 3\cite{safe-initialization-for-scala}.
В данной работе тип несет информацию об уже инициализированных полях($\Omega$), и вводятся три дополнительных подтипа:
\begin{itemize*}
    \item Холодный --- объект не инициализирован.
    \item Теплый --- все поля объекта инициализированы, но он может достигать холодных значений.
    \item Горячий --- объект полностью инициализирован.
\end{itemize*}
Таким образом $C^\Omega$ обозначает, что для класса \emph{C} инициализированы поля $\Omega$.
А запись $C~@cold$ означает, что ни одно свойство класса не было инициализировано.
Такой подход позволил реализовать полноценный typestate полиморфизм, который не мог быть реализован в FBC\@.
А также позволил обращаться к уже инициализированным полям, при этом без использования анализа потока данных.

В результате авторам удалось создать подход, который почти ничем не уступает подходу FBC\@.
Более того превосходит его решая проблемы, которые были не решены в изначальном подходе.
Так, анализ обладает всеми четырьмя приятными свойствами FBC: модульность(локальность), надежность, выразительность, простота.
Но помимо того, что данный подход также не требует большого количества аннотаций,
авторы предоставляют для него еще и автоматический вывод почти всех аннотаций.
Этот подход является и более выразительным, так как авторы прошлого подхода даже не рассматривают такие конструкции как:
лямбды, интерфейсы с реализацией, внутренние классы.
Большим плюсом данного подхода является, то что он реализован для языка Scala 3.
Минусами данного подхода являются:
\begin{itemize*}
    \item Не высокая производительность анализа, авторы статьи заявляют, что анализ увеличивает время компиляции на 20\%.
    \item Не реализована аннотации \emph{@cold} для аргументов конструктора,
    но авторы обходят данный момент в реализации, выводя \emph{@cold} хотя бы для \emph{this}.
\end{itemize*}

\section{Резюме}\label{sec:обзор-резюме}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе были рассмотрены различные подходы для реализации безопасной инициализации.
Так, язык Swift инициализация делится на две стадии.
Во время первой запрещается вызывать методы, обращаться к полям и использовать \emph{self}.
Таким образом избегается доступ к еще не инициализированным полям.
Маскирующие типы, FBC и безопасная инициализация для языка Scala 3 пытаются создать менее радикальный подход,
при этом данные подходы стараются минимально ограничивать программиста в способах инициализации.

