%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Постановка задачи}\label{ch:постановка-задачи}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\mytodo{Какая-то связка}

Исходя из описанного в прошлом разделе, можно выделить набор требований к анализу.
\begin{itemize*}
    \item Не изменять синтаксис языка
    \item Поддержка циклических структур данных и переименования\unsure {aliasing}
    \item Надежность, если предупреждений об ошибках инициализации нет, значит их нет
\end{itemize*}

Не изменять синтаксис языка и не вводить новых конструкций.
Если новый анализ испортит код, который уже был написан на языке Kotlin, то такой анализ никогда не сможет быть принят в язык.
Также, если для правильной работы анализа программисту придется постоянно как-то помечать статус инициализации объектов,
то таким средством никто не будет пользоваться.

Поддержка циклических структур данных и переименования\unsure {aliasing}.
Работы по маскирующим типам, freedom model и безопасной инициализации для Scala 3 сходятся во мнении,
что возможность анализа таких конструкций дает гибкость подходу,
потому что для их поддержки нужно уметь правильно передавать информацию об инициализации объекта.

Надежность, если предупреждений об ошибках инициализации нет, значит их нет.
Данное требование дает некоторые гарантии программисту, который использует анализ.

\mytodo{У меня получилась не постановка задачи, а определение требований. Не уверен как это к задаче свести}