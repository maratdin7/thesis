%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Проблема}\label{ch:проблема-}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\info[inline]{Возможно добавить определение инициализации \href{https://docs.swift.org/swift-book/LanguageGuide/Initialization.html}{в свифт буке} не плохое }

Проблема не полностью инициализированных объектов известна с появления первых объектно-ориентированных языков программирования,
поэтому для данной проблемы существует множество решений, но все эти решения имеют свой набор плюсов и минусов.

Ошибки инициализации имеют достаточно простую природу --- это доступ к еще не инициализированным полям,
но находить ошибки инициализации не просто и они часто являются головной болью для программистов.

Давайте рассмотрим ряд ошибок инициализации для лучшего понимания проблемы.
В приведенном примере, если создать экземпляр класса \emph{Hello}, то программа аварийно завершится
с \emph{NullPointerException}(NPE),
так как во время инициализации свойства \emph{nameLength}, свойство \emph{name} еще не существует.
\nomenclature{NPE}{NullPointerException --- Исключение возникающее, при использовании переменной хранящей null}
\lstinputlisting[
    label={lst:charter01-simple},
    caption={Пример не безопасной инициализации},
    language=Kotlin,
]
{src/charter01/Simple.kt}
Такую ошибку легко увидеть если код состоит из 6 строчек, но если вы разрабатываете большой и сложный класс,
то это становится нетривиальной задачей

Следующий пример показывает, что ошибки инициализации могут появиться и при наследовании.
Проблема заключается в том, что вначале идет инициализация класса родителя, в данном случае класс \emph{A}.
Во время его инициализации будет вызван переопределенный метод \emph{getName},
который обращается к еще не инициализированному свойству \emph{с}.
Оно будет определено только во время инициализации класса \emph{B}.
\lstinputlisting[
    label={lst:charter01-inheritance},
    caption={Пример не безопасной инициализации},
    language=Kotlin,
]
{src/charter01/Inheritance.kt}
На самом деле практически любое переопределение членов класса родителя может привести к ошибкам.
Эта проблема известна, как \textit{проблема хрупкого базового класса}\cite{fragile-base-class-problem}.

Также, проблемы инициализации могут нести в себе и внутренние классы.
Рассмотрим данный пример.
\lstinputlisting[
    label={lst:charter01-inner-class},
    caption={Пример не безопасной инициализации},
    language=Kotlin,
]
{src/charter01/InnerClass.kt}
Проблема заключается в том, что внутренний класс может иметь доступ к \emph{this} еще не достроенного внешнего класса.
Так, класс \emph{Inner} имеет доступ к еще не инициализированному свойству \emph{tag}.

Пример ниже показывает еще один пример не тривиальной ошибки инициализации.
\lstinputlisting[
    label={lst:charter01-static-object},
    caption={Пример не безопасной инициализации},
    language=Kotlin,
]
{src/charter01/StaticObject.kt}
В данном примере во время инициализации свойства \emph{c}, создается экземпляр класса \emph{C}.
Он в свою очередь инициализирует свойство \emph{b}, через свойство \emph{с}, которое еще находится в стадии инициализации.
В данной работе не рассматривается проблема инициализации статических объектов,
но они также могут быть источниками ошибок инициализации, и их поддержка, возможно,
будет добавлена в следующих версиях анализа

Проблема ошибок инициализации создает трудности не только для программистов,
но и для разработчиков компиляторов и дизайнеров языков программирования,
так если в языке нет безопасной инициализации, то нельзя гарантировать неизменяемость или null-безопасность~\cite{joe-duffy}
Kotlin --- это null-безопасный язык, и система типов языка Kotlin гарантирует, что \emph{non-nullable} тип не может быть null.
\lstinputlisting[
    label={lst:charter01-simple1},
    caption={Пример не безопасной инициализации},
    language=Kotlin,
]
{src/charter01/Simple1.kt}
Если попробовать напечатать значение хранящееся в \emph{hello}, то выведется \emph{"Hello, null"},
хотя \emph{name} не может быть null, потому что это гарантирует система типов.
Это делает ошибки инициализации в языке Kotlin менее очевидными и ожидаемыми.

\section{Резюме}\label{sec:проблема-резюме}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе была рассмотрена причина возникновения ошибок инициализации.
Они возникают при обращении к еще не инициализированным полям.
А источником ошибок инициализации могут быть:
\begin{itemize*}
    \item методы
    \item внутренние классы
    \item наследование
    \item статические объекты
    \item итд
\end{itemize*}
В языке Kotlin такие ошибки могут быть менее ожидаемыми, так как это null-безопасный язык.
Также, отмечается, что ошибки инициализации это проблема не только для программистов, но и для дизайнеров языка.