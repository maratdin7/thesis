%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Дизайн}\label{ch:дизайн-}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе будут рассмотрены основные решения принятые во время реализации анализа для языка Kotlin.
Будет рассмотрен подход с помощью, которого анализ будет работать.
Проблемы мешающие применить теорию к языку Kotlin их решения.


\section{Выбор подхода для создания безопасной инициализации в языке Kotlin}
\label{sec:выбор-подхода-для-создания-безопасной-инициализации-в-языке-kotlin}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Решение реализованное в языке Swift, очень хорошо борется с ошибками инициализации.
Но чтобы использовать его в языке Kotlin нужно менять правила инициализации объектов в нем, что будет проблемой,
так как это сломает уже написанный код, а значит такое решение хоть и будет решать проблемы с ошибками инициализации,
но оно никогда не сможет появится в языке Kotlin.

Решение основанное на маскирующих типах, так же является интересным подходом к поиску ошибок инициализации,
но оно вводит достаточно много новых конструкций в язык из-за программисты не захотят использовать такое решение,
потому что это увеличит время разработки программного обеспечения,
но при это не гарантировано решит проблемы с инициализацией.
Вдобавок, это решение не имеет практической реализации в индустриальных языках,
поэтому тяжело определить насколько оно хорошо будет работать в реальном коде.

Учитывая все вышесказанное, для реализации безопасной инициализации для языка Kotlin был выбран подход,
который реализует безопасную инициализацию для языка Scala 3.
Данное решение развивает подход представленный в работе FBC\@.
Оно является одной из первых работ по поиску ошибок инициализации, которая может использоваться на практике.
Также, это решение обладает очень приятным свойством локальности, которое позволяет не анализировать классы по отдельности.
При этом, данное решение не требует изменять синтаксис языка, и оно успешно реализовано в языке Scala 3.


\section{Детали выбранного подхода}\label{sec:детали-выбранного-подхода}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Эффекты и потенциалы}\label{subsec:эффекты-и-потенциалы}

Безопасная инициализация для языка Scala 3 представляет из себя систему типов и эффектов.
Авторы используют эффекты для проверки, что во время инициализации доступ есть только к инициализированным полям.
Так, они вводят три типа эффектов: эффект обращения к полю(!), эффект вызова метода(♢) и эффект продвижения(↑).
\begin{lstlisting}[
    caption={Пример возможных эффектов},
    label={lst:example-for-effects},
    language=Kotlin
]
class B {
    val b: String = foo() // {this.foo♢} -> поле `a` еще не инициализировано
    val a: String = "Hello, "
    fun foo(): String = a 	// {this.a!}
}
\end{lstlisting}
Можно увидеть, что во время инициализации свойства \emph{b},
есть эффект вызова метода, а метод в свою очередь имеет эффект обращения к полю.
Таким образом, можно найти доступ к еще не инициализированному полю \emph{a}.
Эффект продвижения используется для проверки, что объект полностью инициализирован.

Но если программист напишет код ниже, то свойство \emph{a} уже инициализировано, значит оно может безопасно обращаться к \emph{b}?
но это не так.
Для этого авторы подхода предлагают ввести потенциалы.
Они несут информацию об псевдонимах значений, которые могут быть неинициализированными.
\begin{lstlisting}[
    caption={Пример возможных эффектов},
    label={lst:example-for-potentials},
    language=Kotlin
]
class A {
   var a = this
   var b: Int = a.b
}
\end{lstlisting}
Вводится три вида основных потенциалов: потенциал для \emph{this}, потенциал теплого объекта, потенциал холодного объекта.
Если у объекта нет потенциала, то это полностью инициализированный объект и можно безопасно передавать его в любые методы,
и обращаться к любым свойствам.
Потенциалы теплого и холодного объектов рассмотрены в \autoref{sec:безопасная-инициализация-для-языка-scala-3}.
Потенциал для \emph{this} по сути переносит информацию об уже инициализированных полях, данного класса.
Также, вводятся два вспомогательных потенциала потенциал метода, потенциал поля, которые предоставляют информацию,
значение какого потенциала и какого статуса инициализированности получится при выполнении операции.
\unsure[inline ]{Есть еще потенциал для OuterThis и эффект init который появляется после конструктора, но их не очень просто и не очень быстро объяснять}

Авторы вводят ряд ограничений, чтобы обеспечивать локальность анализа.
В методы можно передавать только полностью инициализированные значения.
В аргументы конструктора можно передавать неинициализированные значения, но использовать их там нельзя,
до полной инициализации значения.
Поэтому все аргументы и конструкторов и методов имеют эффект продвижения

\subsection{Full-construction analysis}\label{subsec:full-construction-analysis}

Как упоминалось в \autoref{ch:проблема-} любое переопределение методов и свойств класса родителя может являться причиной ошибок инициализации.
Поэтому авторы предлагают ввести Full-construction analysis(FCA)\nomenclature{FCA}{Full-construction analysis}.
Они представляют конструкторы классов родителей частью конструктора наследника, из-за этого представления все ошибки,
которые могли произойти в результате наследования можно найти методами описанными в \autoref{subsec:эффекты-и-потенциалы}.
Для этого нужно иметь исходный код класса родителя и анализировать еще и его, поэтому анализ не совсем локальный.
Но данный подход помогает найти достаточно не тривиальные ошибки инициализации.
\lstinputlisting[
    label={lst:charter01-initialization-error-with-inheritance-1},
    caption={Пример не безопасной инициализации},
    language=Kotlin,
]
{src/charter01/Inheritance1.kt}
Кажется, что данный пример не должен приводить к \emph{NPE}, так как \emph{а} и \emph{b} правильно инициализируются,
после чего вызывается конструктор \emph{B1}, и завершает создание объекта.
Но в языке Kotlin данный пример приведет к \emph{NPE}.
Для поля автоматически генерируются компилятором геттеры и сеттеры
\unsure {Не уверен что можно использовать такие термины},
и во время инициализации класса \emph{A1} будет вызван уже переопределённый геттер,
который в свою очередь возвращает еще неинициализированное поле \emph{а} класса \emph{B1}.
Но FCA сможет найти данную проблему.
При этом большим плюсом такого анализа является то, что он помогает найти именно ошибки инициализации,
а не просто использования метода, который может быть переопределен в конструкторе.

\subsection{Definite assignment}\label{subsec:definite-assignment}

\mytodo{Нужно чтобы потом опираться во время рассказа про init-блоки итд}


\section{Проблемы подхода для языка Kotlin}\label{sec:проблемы-подхода-для-языка-kotlin}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Выбранный подход создавался для языка Scala 3, что немного упрощает работу по реализации его в языке Kotlin,
так как данные языки имеют много общего.
Но при это есть и ряд различий, которые создают препятствия по созданию анализа в языке Kotlin.

\subsection{Блоки инициализации}\label{subsec:блоки-инициализации}

\subsection{Отложенная инициализация}\label{subsec:lateinit}

В языке Kotlin все свойства должны быть инициализированные к концу построения объекта.
Но существует ключевое слово \emph{lateinit}, которое позволяет инициализировать свойство уже после создания объекта.
Проблема заключается в том, что точка инициализации у данных свойств может находится в любом месте кода \autoref{subsec:definite-assignment}.
Свойство помеченное \emph{lateinit} подразумевает,
что оно будет проинициализировано сразу же после построения объекта.
Значит его можно рассматривать как значение, которое всегда неинициализированное.
При этом код ниже останется не поддержанным, но в данном случае проблема в том,
что программист использует \emph{lateinit} свойство \emph{binding},
когда в данном случае нужно использовать nullable-тип для свойства.
\begin{lstlisting}[
    caption={Пример ошибочного использования \emph{lateinit}},
    label={lst:example-for-lateinit},
    language=Kotlin
]
class MainActivity : AppCompatActivity() {
    lateinit var binding: MainActivityBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = MainActivityBinding.inflate(layoutInflater)
        ...
    }
}
\end{lstlisting}

\subsection{Приемники расширения}\label{subsec:приемники-расширения}

В языке Kotlin у метода может быть не один приемник, как например в языке Java, а два.
На самом деле вместо приемника расширения\info{звучит дуратски, но вроде официально}, можно использовать просто аргумент метода, как показано ниже.
Их поведение с точки зрения анализа никак не отличает от простых аргументов функции, поэтому требуется,
чтобы приемники расширения, тоже были полностью инициализированные.
\begin{lstlisting}[
    caption={Пример использования приемника расширения},
    label={lst:example-for-extention},
    language=Kotlin
]
fun Int.foo() = this
fun foo(i: Int) = i
\end{lstlisting}

\subsection{Делегаты}\label{subsec:делегаты-}

\mytodo{Делегаты и наследование через делегаты(нужно подумать)}

\section{Резюме}\label{sec:резюме-}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В качестве основы для анализа инициализированности в языке Kotlin, был выбран подход реализованный для Scala 3.
Так как он обобщает подходы прошлых лет и имеет ряд приятных свойств.
Также, рассмотрены проблемы, которые пришлось решить для поддержки данного анализа в языке Kotlin